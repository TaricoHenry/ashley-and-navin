/**
 * Admin routes (Basic Auth)
 * - View/edit/export invites + responses
 * - Add invite (token is doc id)
 * NEW REQUESTS:
 * - Token must be 6-char alphanumeric
 * - Invites auto-generate inviteUrl: https://ash-wedding/token/<token>
 */

const express = require("express");
const { requireBasicAuth } = require("../middleware/basicAuth");
const { db } = require("../services/firestore");
const { FieldValue } = require("firebase-admin/firestore");
const { isValidToken, buildInviteUrl, generateToken6 } = require("../utils/token");

const router = express.Router();

/**
 * Admin: get all invites + responses
 * Adds inviteUrl field for display even if it's missing in Firestore docs.
 */
router.get("/admin/data", async (req, res) => {
  if (!requireBasicAuth(req, res)) return;

  const invitesSnap = await db.collection("invites").get();
  const responsesSnap = await db.collection("responses").get();

  const invites = invitesSnap.docs.map((d) => {
    const data = d.data();
    const token = d.id;
    return {
      id: token,
      ...data,
      inviteUrl: data.inviteUrl || buildInviteUrl(token), // ✅ auto-display column
    };
  });

  const responses = responsesSnap.docs.map((d) => ({ id: d.id, ...d.data() }));

  res.send({ invites, responses });
});

/**
 * Admin: update doc fields
 * (logic unchanged)
 */
router.patch("/admin/:collection/:id", async (req, res) => {
  if (!requireBasicAuth(req, res)) return;

  const { collection, id } = req.params;

  if (!["invites", "responses"].includes(collection)) {
    res.status(400).send("Invalid collection");
    return;
  }

  await db.collection(collection).doc(id).update(req.body);
  res.send({ ok: true });
});

/**
 * Admin: create a new invite document (docId = token)
 * NEW REQUEST:
 * - token is ALWAYS autogenerated (6-char alphanumeric)
 * - store inviteUrl field: https://ash-wedding/token/<token>
 */
router.post("/admin/invites", async (req, res) => {
  if (!requireBasicAuth(req, res)) return;

  const body = req.body || {};
  const { token: _t, id: _id, ...rest } = body;

  // Always generate token (6-char alphanumeric)
  let token = generateToken6();

  // Extremely low chance of collision, but we still check to be safe
  // (this is not a logic change to your app flow — it just ensures unique doc ids)
  let tries = 0;
  while (tries < 5) {
    const existing = await db.collection("invites").doc(token).get();
    if (!existing.exists) break;
    token = generateToken6();
    tries++;
  }

  // If somehow still colliding after retries
  const finalExisting = await db.collection("invites").doc(token).get();
  if (finalExisting.exists) {
    res.status(500).send({ message: "Failed to generate unique token. Try again." });
    return;
  }

  await db.collection("invites").doc(token).set({
    ...rest,
    token, // optional, handy
    inviteUrl: buildInviteUrl(token),
    createdAt: FieldValue.serverTimestamp(),
    usedAt: null,
  });

  res.status(201).send({
    ok: true,
    id: token,
    token,
    inviteUrl: buildInviteUrl(token),
  });
});


/**
 * Admin dashboard page (plain HTML)
 * - Add Invite form
 * - Generate Token button (6-char alphanumeric)
 * - Invites table includes inviteUrl column
 * - Uses relative fetch paths (./admin/data) so it works under the function URL.
 */
router.get("/admin", (req, res) => {
  if (!requireBasicAuth(req, res)) return;

  res.set("Content-Type", "text/html");
  res.send(`
<!DOCTYPE html>
<html>
<head>
  <title>Wedding Admin</title>
  <meta charset="utf-8" />
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    h2 { margin-top: 40px; }
    table { border-collapse: collapse; width: 100%; margin-top: 10px; }
    th, td { border: 1px solid #ccc; padding: 6px; font-size: 14px; vertical-align: top; }
    th { background: #f3f3f3; position: sticky; top: 0; }
    td[contenteditable] { background: #fffbe6; }
    td[contenteditable]:focus { outline: 2px solid #ffd54f; }
    button { margin-right: 10px; }
    .muted { color: #777; font-size: 12px; }
    .box { margin: 10px 0; padding: 10px; border: 1px solid #ddd; }
    input { margin-right: 10px; }
    .row { margin-top: 8px; }
  </style>
</head>
<body>

<h1>Wedding Admin Dashboard</h1>
<p class="muted">Click a cell to edit. Changes save automatically on blur. Exports generate CSV from what you see.</p>

<h2>Invites</h2>

<div class="box">
  <b>Add Invite</b>
  <p class="muted">
    Token is autogenerated (6-character alphanumeric). 
    Invite URL auto-generates as https://ash-wedding/token/&lt;token&gt;
  </p>

  <div class="row">
    <input id="newGuestName" placeholder="guestName" />
    <input id="newRoute" placeholder="route (A/B/etc)" />
    <button onclick="addInvite()">Add</button>
    <span id="addInviteMsg" class="muted"></span>
  </div>
</div>

<button onclick="exportCSV('invites')">Export Invites CSV</button>
<table id="invites"></table>

<h2>Responses</h2>
<button onclick="exportCSV('responses')">Export Responses CSV</button>
<table id="responses"></table>

<script>
async function loadData() {
  const res = await fetch("./admin/data");
  if (!res.ok) {
    alert("Failed to load admin data");
    return;
  }
  const data = await res.json();
  renderTable("invites", data.invites);
  renderTable("responses", data.responses);
}

// basic formatting so timestamps render nicely
function formatCellValue(v) {
  if (v === null || v === undefined) return "";

  // Firestore Timestamp (Admin SDK often comes back like this)
  if (typeof v === "object") {
    // Timestamp object with toDate()
    if (typeof v.toDate === "function") {
      return v.toDate().toLocaleString();
    }

    // Timestamp-like shape: { _seconds, _nanoseconds }
    if (typeof v._seconds === "number") {
      return new Date(v._seconds * 1000).toLocaleString();
    }

    // Timestamp-like shape: { seconds, nanoseconds }
    if (typeof v.seconds === "number") {
      return new Date(v.seconds * 1000).toLocaleString();
    }

    // Fallback
    return JSON.stringify(v);
  }

  return String(v);
}


function renderTable(tableId, rows) {
  const table = document.getElementById(tableId);
  table.innerHTML = "";

  if (!rows || rows.length === 0) {
    table.innerHTML = "<tr><td>No data</td></tr>";
    return;
  }

  // union columns so table doesn't break if docs have different fields
const colSet = new Set();
rows.forEach(r => Object.keys(r || {}).forEach(k => colSet.add(k)));
let columns = Array.from(colSet);

// Preferred column order per table
const preferredOrder = {
  invites: [
    "id",
    "token",
    "guestName",
    "route",
    "inviteUrl",
    "createdAt",
    "usedAt",
  ],
  responses: [
    "id",
    "token",
    "guestName",
    "route",
    "rsvp",
    "allergies",
    "allergyDescription",
    "songRequest",
    "submittedAt",
  ],
};

// Reorder columns: preferred first, then everything else
if (preferredOrder[tableId]) {
  const preferred = preferredOrder[tableId];
  columns = [
    ...preferred.filter(c => columns.includes(c)),
    ...columns.filter(c => !preferred.includes(c)),
  ];
}


  // Header
  const header = document.createElement("tr");
  columns.forEach(col => {
    const th = document.createElement("th");
    th.innerText = col;
    header.appendChild(th);
  });
  table.appendChild(header);

  // Rows
  rows.forEach(row => {
    const tr = document.createElement("tr");

    columns.forEach(col => {
      const td = document.createElement("td");
      td.innerText = formatCellValue(row[col]);

      // Don't let people edit doc id, token, or timestamp fields
      const readOnlyCols = new Set(["id", "token", "createdAt", "submittedAt", "usedAt"]);
      td.contentEditable = !readOnlyCols.has(col);

      td.onblur = async () => {
        if (col === "id") return;
        await saveCell(tableId, row.id, col, td.innerText);
      };

      tr.appendChild(td);
    });

    table.appendChild(tr);
  });
}

async function saveCell(collection, id, field, value) {
  await fetch("./admin/" + collection + "/" + id, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ [field]: value })
  });
}

function exportCSV(tableId) {
  const table = document.getElementById(tableId);
  const rows = [...table.querySelectorAll("tr")];

  const csv = rows.map(row =>
    [...row.children].map(cell =>
      '"' + cell.innerText.replace(/"/g, '""') + '"'
    ).join(",")
  ).join("\\n");

  const blob = new Blob([csv], { type: "text/csv" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = tableId + ".csv";
  a.click();
}

async function addInvite() {
  const guestName = document.getElementById("newGuestName").value.trim();
  const route = document.getElementById("newRoute").value.trim();
  const msg = document.getElementById("addInviteMsg");

  msg.innerText = "";

  const payload = {};
  if (guestName) payload.guestName = guestName;
  if (route) payload.route = route;

  const res = await fetch("./admin/invites", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });

  const data = await res.json().catch(() => ({}));

  if (!res.ok) {
    msg.innerText = data.message || "Failed to add invite";
    return;
  }

  // Show generated token + url immediately
  if (data.token && data.inviteUrl) {
    msg.innerText = \`Invite created: \${data.token} (\${data.inviteUrl})\`;
  } else if (data.token) {
    msg.innerText = \`Invite created: \${data.token}\`;
  } else {
    msg.innerText = "Invite created!";
  }

  document.getElementById("newGuestName").value = "";
  document.getElementById("newRoute").value = "";

  await loadData();
}

loadData();
</script>

</body>
</html>
`);
});


module.exports = router;
